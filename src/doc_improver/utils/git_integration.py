"""Git integration for automated commits and PR creation."""

import subprocess
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime
import logging

try:
    from git import Repo, GitCommandError
    GIT_AVAILABLE = True
except ImportError:
    GIT_AVAILABLE = False
    Repo = None

from doc_improver.models import DocumentationImprovement
from doc_improver.utils.logger import setup_logger

logger = setup_logger(__name__)


class GitIntegration:
    """Handles git operations for documentation improvements."""

    def __init__(self, repo_path: Optional[Path] = None):
        """Initialize git integration.

        Args:
            repo_path: Path to git repository (default: current directory)
        """
        if not GIT_AVAILABLE:
            raise ImportError("GitPython is required for git integration. Install with: pip install gitpython")

        self.repo_path = repo_path or Path.cwd()

        try:
            self.repo = Repo(self.repo_path, search_parent_directories=True)
        except Exception as e:
            raise ValueError(f"Not a git repository: {self.repo_path}. Error: {e}")

        if self.repo.bare:
            raise ValueError("Cannot work with bare repositories")

    def get_current_branch(self) -> str:
        """Get current branch name.

        Returns:
            Branch name
        """
        return self.repo.active_branch.name

    def create_feature_branch(self, branch_name: Optional[str] = None) -> str:
        """Create a new feature branch for documentation changes.

        Args:
            branch_name: Optional branch name (auto-generated if not provided)

        Returns:
            Name of created branch
        """
        if branch_name is None:
            timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
            branch_name = f"docs/auto-improvements-{timestamp}"

        # Check if branch already exists
        if branch_name in [b.name for b in self.repo.branches]:
            logger.warning(f"Branch {branch_name} already exists, using it")
            self.repo.git.checkout(branch_name)
        else:
            # Create new branch
            self.repo.git.checkout('-b', branch_name)
            logger.info(f"Created branch: {branch_name}")

        return branch_name

    def commit_improvements(
        self,
        improvements: List[DocumentationImprovement],
        message: Optional[str] = None
    ) -> str:
        """Commit documentation improvements.

        Args:
            improvements: List of applied improvements
            message: Optional commit message

        Returns:
            Commit SHA
        """
        # Get list of modified files
        modified_files = set()
        for imp in improvements:
            if imp.gap.entity:
                modified_files.add(imp.gap.entity.file_path)

        if not modified_files:
            logger.warning("No files to commit")
            return ""

        # Stage the files
        for file_path in modified_files:
            try:
                self.repo.index.add([file_path])
            except Exception as e:
                logger.error(f"Error staging {file_path}: {e}")

        # Create commit message
        if message is None:
            message = self._generate_commit_message(improvements)

        # Commit
        try:
            commit = self.repo.index.commit(message)
            logger.info(f"Created commit: {commit.hexsha[:8]}")
            return commit.hexsha
        except Exception as e:
            logger.error(f"Error creating commit: {e}")
            raise

    def _generate_commit_message(self, improvements: List[DocumentationImprovement]) -> str:
        """Generate commit message for improvements.

        Args:
            improvements: List of improvements

        Returns:
            Commit message
        """
        total = len(improvements)
        high_conf = len([i for i in improvements if i.confidence_score >= 0.8])

        # Count by severity
        critical = len([i for i in improvements if i.gap.severity.value == 'critical'])
        high = len([i for i in improvements if i.gap.severity.value == 'high'])

        message_parts = [
            "docs: Auto-generated documentation improvements",
            "",
            f"Added/improved documentation for {total} code entities:",
            f"- {high_conf} high-confidence improvements",
            f"- {critical} critical gaps addressed",
            f"- {high} high-priority gaps addressed",
            "",
            "Generated by Self-Driving Documentation Improver",
        ]

        return "\n".join(message_parts)

    def push_branch(self, branch_name: Optional[str] = None, force: bool = False) -> bool:
        """Push branch to remote.

        Args:
            branch_name: Branch to push (default: current branch)
            force: Whether to force push

        Returns:
            True if successful
        """
        if branch_name is None:
            branch_name = self.get_current_branch()

        try:
            origin = self.repo.remote('origin')

            if force:
                origin.push(branch_name, force=True)
            else:
                origin.push(branch_name)

            logger.info(f"Pushed branch {branch_name} to origin")
            return True
        except Exception as e:
            logger.error(f"Error pushing branch: {e}")
            return False

    def create_pull_request_cli(
        self,
        title: Optional[str] = None,
        body: Optional[str] = None,
        base_branch: str = "main"
    ) -> Optional[str]:
        """Create pull request using GitHub CLI.

        Args:
            title: PR title
            body: PR description
            base_branch: Base branch to merge into

        Returns:
            PR URL or None if failed
        """
        try:
            # Check if gh CLI is available
            subprocess.run(['gh', '--version'], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            logger.error("GitHub CLI (gh) not found. Install from: https://cli.github.com/")
            return None

        if title is None:
            title = "docs: Automated documentation improvements"

        if body is None:
            body = """
## Summary

This PR contains automatically generated documentation improvements created by the Self-Driving Documentation Improver.

## Changes

- Added/updated docstrings for undocumented code entities
- Improved parameter and return value documentation
- Added usage examples where appropriate

## Review Notes

- All improvements were generated using Claude AI
- High-confidence changes (>70%) were applied automatically
- Please review for accuracy and completeness

Generated by: Self-Driving Documentation Improver
"""

        try:
            # Create PR using gh CLI
            result = subprocess.run(
                [
                    'gh', 'pr', 'create',
                    '--title', title,
                    '--body', body,
                    '--base', base_branch
                ],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True
            )

            pr_url = result.stdout.strip()
            logger.info(f"Created pull request: {pr_url}")
            return pr_url

        except subprocess.CalledProcessError as e:
            logger.error(f"Error creating PR: {e.stderr}")
            return None

    def get_changed_files(self, base_branch: str = "main") -> List[str]:
        """Get list of changed files compared to base branch.

        Args:
            base_branch: Branch to compare against

        Returns:
            List of changed file paths
        """
        try:
            diff = self.repo.git.diff('--name-only', base_branch)
            return diff.splitlines() if diff else []
        except Exception as e:
            logger.error(f"Error getting changed files: {e}")
            return []

    def is_clean(self) -> bool:
        """Check if working directory is clean.

        Returns:
            True if no uncommitted changes
        """
        return not self.repo.is_dirty()

    def get_status(self) -> Dict[str, Any]:
        """Get repository status.

        Returns:
            Status dictionary
        """
        return {
            'branch': self.get_current_branch(),
            'is_clean': self.is_clean(),
            'untracked_files': self.repo.untracked_files,
            'modified_files': [item.a_path for item in self.repo.index.diff(None)],
            'staged_files': [item.a_path for item in self.repo.index.diff('HEAD')],
        }


def create_documentation_pr_workflow(
    improvements: List[DocumentationImprovement],
    repo_path: Optional[Path] = None,
    base_branch: str = "main",
    auto_push: bool = False
) -> Optional[str]:
    """Complete workflow to create a PR with documentation improvements.

    Args:
        improvements: List of improvements to commit
        repo_path: Repository path
        base_branch: Base branch for PR
        auto_push: Whether to automatically push

    Returns:
        PR URL or None
    """
    try:
        git = GitIntegration(repo_path)

        # Create feature branch
        branch_name = git.create_feature_branch()

        # Commit improvements
        commit_sha = git.commit_improvements(improvements)

        if not commit_sha:
            logger.error("No commit created")
            return None

        # Push if requested
        if auto_push:
            if not git.push_branch(branch_name):
                logger.error("Failed to push branch")
                return None

            # Create PR
            pr_url = git.create_pull_request_cli(base_branch=base_branch)
            return pr_url
        else:
            logger.info(f"Branch {branch_name} created. Push manually to create PR.")
            logger.info(f"  git push -u origin {branch_name}")
            return None

    except Exception as e:
        logger.error(f"Error in PR workflow: {e}", exc_info=True)
        return None
